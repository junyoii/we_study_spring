# 스프링 DB 접근 기술
이전에 했던것은 데이터를 메모리에 저장을 하고 서버가 내려가면 메모리에 있던 데이터가 사라졌음, 실무에서는 이러면 안되니까 데이터베이스에 데이터를 저장하고 관리함<br>
회원 객체를 아래의 기술들을 적용해가면서 한단계씩 바꿔볼 것임(메모리 리포지토리→Jdbc 리포지토리→JPA 리포지토리)

1. **H2 데이터베이스 설치**
2. **순수 Jdbc**
3. **스프링 통합 테스트**
4. **스프링 JdbcTemplate**
5. **JPA**
6. **스프링 데이터 JPA**
<br>
<br>

## **1. H2 데이터베이스 설치**
---
1. **H2 데이터베이스 설치시 주의사항**
  <br>
* H2 데이터베이스가 정상 생성되지 않는 경우 URL의 포트번호 앞 임의의 숫자를 localhost로 변경한다
* 데이터베이스 파일 생성 후 홈 디렉토리에서 `~/test.mv.db` 파일 생성 여부 확인
* 처음에 설치를 하고 이후에는 JDBC URL에 `jdbc:h2:tcp://localhost/~/test`을 입력해 접속 → 직접 접속(꼬일 수 있음)이 아닌 소켓을 이용한 접속
2. **member 테이블 생성**
  <br>
    ```sql
    drop table if exists member CASCADE; // 테이블 삭제

    create table member; // 테이블 생성
    (
        id bigint generated by default as identity, // id는 자동 생성
        name varchar(255),
        primary key(id)
    );

    insert into member(name) values('spring'); // 테이블에 데이터 삽입
    ```
    H2 데이터베이스에 접근해서 `member` 테이블 생성
<br>
<br>

## **2. 순수 Jdbc**
---
<span style="color:Orange; font-size:18px">1. 구현 과정 PASS</span><br>

**2. 왜 스프링을 사용하는가?**<br>
![구현 클래스 이미지](./pic/jdbcRepo.png)
* 기존에 MemberRepository는 구현체인 MemoryMemberRepository를 스프링 컨테이너에서 스프링빈으로 등록 
* JdbcMemberRepository를 만들고 SpringConfig에서 MemoryMemberRepository를 JdbcMemberRepository로 바꿈 → MemberRepository의 구현체에 JdbcMemberRepository가 새로 추가되고 스프링빈으로 등록
* 인터페이스를 두고 구현체를 바꿔끼우는 다형성을 스프링에서 편리하게 사용할 수 있게 지원
* 다형성을 잘 활용하면 확장에는 열려있고 수정과 변경에는 닫혀있는 개방-폐쇄의 원칙이 적용 → 스프링을 사용하는 이유
<br>
<br>

## **3. 스프링 통합 테스트**
---
**1. 회원 서비스 스프링 통합 테스트**
  <br>
  이전에 했던 테스트는 스프링과 전혀 관련 없는 순수 자바 코드로만 진행한 테스트였으나 현재는 데이터베이스 정보를 스프링부트가 가지고 있어 순수 자바 코드로 테스트를 진행할 수 없다<br>
  → 스프링 컨테이너와 DB까지 연결해서 동작하는 통합 테스트를 진행해야 한다<br>
  → 통합 테스트도 필요한 경우 해야하지만 통합 테스트보단 단위 테스트가 더 중요한 경우가 많은 것을 염두하자!<br><br>
  <span style="color:Orange; font-size:18px">2. 구현 과정 PASS</span><br><br>
**3. 몇 가지 annotation**<br>
* @SpringBootTest : 스프링 컨테이너와 테스트를 함께 시작한다
* @Transactional : 테스트 실행 시 트랜잭션을 먼저 실행하고, 테스트가 끝나면 rollback을 해 DB에 넣었던 데이터를 깔끔하게 지워줘서 반복해서 테스트를 할 수 있다
<br>
<br>

## **4. 스프링 JdbcTemplate**
---
**1. 스프링 JdbcTemplate**
  <br>
  순수 Jdbc로 개발하기 어려워서 스프링이 반복 코드를 제거한 JdbcTemplate이라는 기술을 제공. SQL은 직접 작성해야 하지만, 이를 통해 애플리케이션에서 데이터베이스로 SQL을 편하게 보낼 수 있음<br><br>

**2. 스프링 JdbcTemplate 회원 리포지토리**
  <br>
  ```java
public class JdbcTemplateMemberRepository implements MemberRepository{

    private final JdbcTemplate jdbcTemplate;

    // 생성자가 한 개인 경우 autowired를 생략해도 됨
    // Spring에서 dataSource를 자동으로 injection 해줌
    public JdbcTemplateMemberRepository(DataSource dataSource){
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        // 쿼리를 짤 필요 없이 insert문을 만들 수 있음
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());

        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id); // 쿼리의 결과를 rowmapper에 매핑
        return result.stream().findAny();
        //jdbc에서 겁나 긴것을 단 2줄로!
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    private RowMapper<Member> memberRowMapper() {
        return new RowMapper<Member>() {
            @Override
            public Member mapRow(ResultSet rs, int rowNum) throws SQLException {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return member;
            }
        };
    }
}
```
<br>

**3. JdbcTemplate을 사용하도록 스프링 설정 변경**
  <br>
```java
public MemberRepository memberRepository() {
        return new JdbcTemplateMemberRepository(dataSource);
    }
```
<br>

## **5. JPA**
---

**1. JPA**
  <br>
JPA는 JdbcTemplate의 장점인 반복 코드 제거뿐만 아니라 기본적인 SQL은 JPA에서 자동으로 처리해주어 직접 SQL을 만들지 않고도 객체를 데이터베이스에 저장하고 관리할 수 있음<br>
→ SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환, 개발 생산성을 크게 높임

<br>

**2. build.gradle 파일에 JPA, h2 데이터베이스 관련 라이브러리 추가**
  <br>
  build.gradle에서
  ```java
  //기존의 jdbc 라이브러리 제거 후 jpa 라이브러리 추가
  //implementation 'org.springframework.boot:spring-boot-starter-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  ```

<br>

**3. 스프링 부트에 JPA 설정 추가**
  <br>
    application.properties에서 
  ```java
  //jpa가 날리는 sql을 볼 수 있음
spring.jpa.show-sql=true
//jpa에서는 객체가 있으면 테이블도 저절로 생성해주는데 그 기능을 off
spring.jpa.hibernate.ddl-auto=none
  ```

<br>

**4. JPA 엔티티 매핑**
  <br>
  JPA는 ORM 기술(객체와 데이터베이스를 매핑)을 사용하기 때문에 entity 매핑을 해주어야 함<br>

  Member.class에서
  ```java
  // @Entity : JPA가 관리하는 entity라는 annotation
@Entity

public class Member { 
    // PK 매핑, IDENTITY(DB가 알아서 Id 번호를 생성)
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; //로그인 id가 아닌 식별하기 위해 자동 count 해주는 id

    // 객체의 멤버 변수명과 DB의 column명이 서로 다른 경우
    @Column(name = "username")
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
  ```
<br>

**5. JPA 회원 리포지토리**
  <br>
  JpaMemberRepository.class를 생성해서
  ```java
  public class JpaMemberRepository implements MemberRepository {

        // jpa는 entity manager로 모든 것이 동작
        private final EntityManager em;

        public JpaMemberRepository(EntityManager em) {
            this.em = em;
        }

        @Override
        public Member save(Member member) {
            em.persist(member);
            return member;
        }

        @Override
        public Optional<Member> findById(Long id) {
            Member member = em.find(Member.class, id);
            return Optional.ofNullable(member);
        }

        //PK기반이 아닌 것들은 jpql이라는 쿼리 사용 : 엔티티를 대상으로 쿼리를 날림
        @Override
        public Optional<Member> findByName(String name) {
            List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class).setParameter("name", name).getResultList();
            return result.stream().findAny();
        }

        @Override
        public List<Member> findAll() {
            List<Member> result = em.createQuery("select m from Member m", Member.class).getResultList();
            return result;
        }
}
  ```
<br>

**6. 서비스 계층에 트랜잭션 추가**
  <br>
jpa는 항상 트랜잭션이 있어야 함 → service 계층에 추가
```java
@Transactional
public class MemberService {
  ...생략
}
```
<br>

**7. JPA를 사용하도록 스프링 설정 변경**
  <br>
  SpringConfig.java에 MemberRepository의 구현체로 JpaMemberRepository 새로 추가
  ```java
  @Configuration
public class SpringConfig {

    private EntityManager em;

    @Autowired
    public SpringConfig(EntityManager em) {
        this.em=em;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }
    @Bean
    public MemberRepository memberRepository() {
        return new JpaMemberRepository(em);
    }
}
  ```

  <span style="color:red; font-size:16px; font-weight:bold">이 모든 과정을 해내고 테스트를 돌리면 자동으로 매핑된 sql문을 확인할 수 있습니다</span>
<br>
<br>

## **6. 스프링 데이터 JPA**
---

**1. 스프링 데이터 JPA**
  <br>
  스프링 데이터 JPA를 사용하면 리포지토리에 구현 클래스 없이 인터페이스만으로 개발을 할 수 있고, CRUD 기능도 스프링 데이터 JPA가 모두 제공한다<br>
  <span style="color:red">실무에서 관계형 데이터베이스를 사용하면 스프링 데이터 JPA는 필수입니다! 하지만 스프링 데이터 JPA를 학습하기 이전에 꼭 JPA를 학습해야 합니다!</span>
  <br>
  <br>
**2. 스프링 데이터 JPA 회원 리포지토리**
  <br>
  ```java
  //interface에서 interface를 받을 때는 implements가 아닌 extends!
public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {

    //이렇게 하면 끝입니다 구현할게 없습니다
    @Override
    Optional<Member> findByName(String name);
}
  ```
  <br>

**3. 스프링 데이터 JPA 회원 리포지토리를 사용하도록 스프링 설정 변경**
  <br>

  ```java
@Configuration
public class SpringConfig {

    //스프링 데이터 JPA가 JpaRepository를 받고 있으면 구현체를 자동으로 만들어줘서 SpringDataJpaMemberRepository가 자동으로 등록된다
    private final MemberRepository memberRepository;

    @Autowired
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository=memberRepository;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository);
    }
}
  ```
  <br>
  
**4. 스프링 데이터 JPA 제공 클래스**
  ![구현 클래스 이미지](./pic/jpaClass.png)
  <br>
  <br>

**5. 스프링 데이터 JPA 제공 기능**
  <br>
  * 인터페이스를 통한 기본적인 CRUD
  * `findByName()`, `findByEmail()`처럼 메서드 이름만으로 조회 기능 제공
  * 페이징 기능 자동 제공
  * 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용한다.  이 조합으로 해결하기 어려운 쿼리는 네이티브 쿼리를 사용하거나, JdbcTemplate를 사용하면 된다.